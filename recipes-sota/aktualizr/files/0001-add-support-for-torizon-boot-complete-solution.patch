From 8322d84ffc21a0bf19a4e6bbf7308afa5d4bcbcd Mon Sep 17 00:00:00 2001
From: Naeem Khan <naeem.khan@toradex.com>
Date: Fri, 17 Apr 2020 20:48:51 -0400
Subject: [PATCH] add support for torizon boot complete solution

mmc based modules require mmc boot partition to be unlocked before
setting u-boot environment variables

Signed-off-by: Naeem Khan <naeem.khan@toradex.com>
---
 src/libaktualizr/bootloader/bootloader.cc | 49 +++++++++++++++++++++++
 1 file changed, 49 insertions(+)

diff --git a/src/libaktualizr/bootloader/bootloader.cc b/src/libaktualizr/bootloader/bootloader.cc
index 97389356..82a9900f 100644
--- a/src/libaktualizr/bootloader/bootloader.cc
+++ b/src/libaktualizr/bootloader/bootloader.cc
@@ -6,6 +6,7 @@
 #include <unistd.h>
 
 #include <boost/filesystem.hpp>
+#include <boost/algorithm/string.hpp>
 
 #include "storage/invstorage.h"
 #include "utilities/exceptions.h"
@@ -26,6 +27,10 @@ Bootloader::Bootloader(BootloaderConfig config, INvStorage& storage) : config_(s
 
 void Bootloader::setBootOK() const {
   std::string sink;
+  std::string boot_env_partition;
+  std::string unlock_mmc_cmd("echo 0 > /sys/block/");
+  std::string lock_mmc_cmd("echo 1 > /sys/block/");
+
   switch (config_.rollback_mode) {
     case RollbackMode::kBootloaderNone:
       break;
@@ -35,12 +40,32 @@ void Bootloader::setBootOK() const {
       }
       break;
     case RollbackMode::kUbootMasked:
+      if(Utils::shell("readlink /dev/emmc-boot0", &sink) != 0) {
+        LOG_WARNING << "Failed getting boot environment partition";
+      }else
+      {
+        boot_env_partition = sink;
+        boost::trim(boot_env_partition);
+        unlock_mmc_cmd = unlock_mmc_cmd + boot_env_partition + "/force_ro";
+        if (Utils::shell(unlock_mmc_cmd, &sink) != 0) {
+         LOG_WARNING << "Failed unlocking mmc" + unlock_mmc_cmd;
+        }
+      }
+       
       if (Utils::shell("fw_setenv bootcount 0", &sink) != 0) {
         LOG_WARNING << "Failed resetting bootcount";
       }
       if (Utils::shell("fw_setenv upgrade_available 0", &sink) != 0) {
         LOG_WARNING << "Failed resetting upgrade_available for u-boot";
       }
+      
+      if(! boot_env_partition.empty())
+      {
+        lock_mmc_cmd = lock_mmc_cmd + boot_env_partition + "/force_ro";
+        if (Utils::shell(lock_mmc_cmd, &sink) != 0) {
+          LOG_WARNING << "Failed locking mmc" + lock_mmc_cmd;
+        }
+      }
       break;
     default:
       throw NotImplementedException();
@@ -49,6 +74,10 @@ void Bootloader::setBootOK() const {
 
 void Bootloader::updateNotify() const {
   std::string sink;
+  std::string boot_env_partition;
+  std::string unlock_mmc_cmd("echo 0 > /sys/block/");
+  std::string lock_mmc_cmd("echo 1 > /sys/block/");
+
   switch (config_.rollback_mode) {
     case RollbackMode::kBootloaderNone:
       break;
@@ -61,6 +90,18 @@ void Bootloader::updateNotify() const {
       }
       break;
     case RollbackMode::kUbootMasked:
+      if(Utils::shell("readlink /dev/emmc-boot0", &sink) != 0) {
+        LOG_WARNING << "Failed getting boot environment partition";
+      }else
+      {
+        boot_env_partition = sink;
+        boost::trim(boot_env_partition);
+        unlock_mmc_cmd = unlock_mmc_cmd + boot_env_partition + "/force_ro";
+        if (Utils::shell(unlock_mmc_cmd, &sink) != 0) {
+         LOG_WARNING << "Failed unlocking mmc";
+        }
+      }
+
       if (Utils::shell("fw_setenv bootcount 0", &sink) != 0) {
         LOG_WARNING << "Failed resetting bootcount";
       }
@@ -70,6 +111,14 @@ void Bootloader::updateNotify() const {
       if (Utils::shell("fw_setenv rollback 0", &sink) != 0) {
         LOG_WARNING << "Failed resetting rollback flag";
       }
+
+      if(! boot_env_partition.empty())
+      {
+        lock_mmc_cmd = lock_mmc_cmd + boot_env_partition + "/force_ro";
+        if (Utils::shell(lock_mmc_cmd, &sink) != 0) {
+          LOG_WARNING << "Failed locking mmc";
+        }
+      }
       break;
     default:
       throw NotImplementedException();
-- 
2.17.1

